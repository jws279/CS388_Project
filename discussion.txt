As can be seen from the results above, the CDC7600 performs better than the CDC6600 in every case. For the first equation (Y = AX^2 + B), one of the biggest bottlenecks were true data dependencies from functional units being forced to wait for previous multiplication operations to write the result to the register so that it can be read by the next instruction. The CDC7600 was able to perform significantly better here because of a substantially sped-up multiplication operation, resulting in less waiting.

For the second equation (Y = AX^2 + Bx + C), the CSDC7600 was again able to substantially outperform the CDC6600 as a result of quicker operations, namely multiplication, and shorter memory access times. As a result, it didn't have to wait as long for the true data dependencies to be resolved.

The result of the third equation followed the same trend as the previous two with the CDC7600 noticeably outperforming the CDC6600; however, it was by a proportionally smaller amount than with the previous ones. The cause of this is the frequent branching that takes place while looping over the small number of instructions present, as well as the data dependencies in the instructions that are being iteratively executed.
